function GS_basis_pos_xy = Basis_GramSchmidt2(x,y,Kx,Ky,d2k,GS_basis_mom)
    % Manually evaluates the GS basis in position space at the sample locations x,y
    % as this is a fourier transform over a non-uniform point set.
    
    
    % do in batches for memory limits
    n_pts = numel(x);
    batch_size = 200;
    n_batches = floor(n_pts/batch_size);
    remainder = rem(n_batches,batch_size);
    
    b_start = ;
    b_end = batch_size;
    
    
    for k = 0:n_batches-1
        
        if k == n_batches-1
            batch = b_start:(b_start+remainder);
        else
            batch = b_start:b_end;
        end
        
        FT_exp_xy = exp(1i * ( x.*Kx.' + y.*Ky.') );
        GS_basis_pos_xy = 1/(2*pi) * d2k * FT_exp_xy * GS_basis_mom;
        
        % reset start and stop indices
        b_start = b_end+1;
        b_end = b_end + batch_size;
        
    end
    
    
    
    FT_exp_xy = exp(1i * ( x.*Kx.' + y.*Ky.') );
    GS_basis_pos_xy = 1/(2*pi) * d2k * FT_exp_xy * GS_basis_mom; 
    
    
    %{
    pre-vectorization implementation
    
    
    %d2k = (Kx(1,2)-Kx(1,1))*(Ky(2,1)-Ky(1,1));
 
    % vectorize the modes
    GS_basis_mom = reshape(GS_basis_mom, [1,numel(Kx),size(GS_basis_mom,3)]);
    
    FT_exp_xy = exp(1i * ( x.*Kx(:)' + y.*Ky(:)' ) ); % exponential terms in fourier transform
    GS_basis_pos_xy = 1/(2*pi) * sum( GS_basis_mom .* FT_exp_xy ,2) .* d2k;

    GS_basis_pos_xy = squeeze(GS_basis_pos_xy);
    %}
end
